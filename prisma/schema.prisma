// This is your Prisma schema file for the Universal AI Agent System
// Optimized for Render hobby plan (512MB RAM)
// Database: PostgreSQL with connection pooling

generator client {
  provider = "prisma-client-js"
  previewFeatures = ["fullTextSearch", "fullTextIndex"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // Connection pooling optimized for Render hobby plan

  // Max 5 connections to stay within resource limits
}

// ============================================================================
// USER & AUTHENTICATION
// ============================================================================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  role          UserRole  @default(USER)
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
  agents        Agent[]
  threads       Thread[]
  provider Keys  ProviderKey[]
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([email])
  @@index([role])
}

enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ============================================================================
// LLM PROVIDER KEYS & CONFIGURATION
// ============================================================================

model ProviderKey {
  id        String   @id @default(cuid())
  userId    String
  provider  String   // openai, anthropic, groq, google, ollama, azure-openai
  keyHash   String   // Encrypted API key (AES-256)
  keyName   String?  // Optional user-friendly name
  isActive  Boolean  @default(true)
  
  // Usage tracking
  totalTokens Int     @default(0)
  totalCost   Float   @default(0.0)
  
  // Quota limits (optional)
  monthlyTokenLimit Int?
  monthlyCostLimit  Float?
  
  // Metadata
  lastUsedAt  DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider, keyName])
  @@index([userId])
  @@index([provider])
  @@index([isActive])
}

// ============================================================================
// AGENT DEFINITIONS
// ============================================================================

model Agent {
  id            String   @id @default(cuid())
  userId        String
  name          String
  role          String   // researcher, coder, analyst, planner, critic, executor, manager
  systemPrompt  String   @db.Text
  
  // LLM Configuration
  provider      String   // Preferred provider
  model         String?  // Specific model (e.g., gpt-4, claude-3-sonnet)
  temperature   Float    @default(0.7)
  maxTokens     Int      @default(2000)
  
  // Tool Configuration
  tools         Json     // Array of tool names enabled for this agent
  
  // Status
  isActive      Boolean  @default(true)
  
  // Metadata
  description   String?  @db.Text
  metadata      Json?    // Additional custom configuration
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  threads       Thread[]
  taskExecutions TaskExecution[]

  @@index([userId])
  @@index([role])
  @@index([isActive])
}

// ============================================================================
// CONVERSATION THREADS & MESSAGES
// ============================================================================

model Thread {
  id        String    @id @default(cuid())
  userId    String
  agentId   String?   // Optional: thread can be associated with specific agent
  title     String    @default("New Conversation")
  
  // LLM Provider Used
  provider  String?   // Which provider was used
  model     String?   // Which model was used
  
  // Cost Tracking
  totalTokens Int     @default(0)
  totalCost   Float   @default(0.0)
  
  // Status
  isArchived  Boolean @default(false)
  
  // Metadata
  metadata    Json?   // Custom metadata
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  agent       Agent?   @relation(fields: [agentId], references: [id], onDelete: SetNull)
  messages    Message[]

  @@index([userId])
  @@index([agentId])
  @@index([createdAt])
  @@index([isArchived])
}

model Message {
  id          String   @id @default(cuid())
  threadId    String
  role        String   // system, user, assistant, tool
  content     String?  @db.Text
  
  // Tool Calling
  toolCalls   Json?    // OpenAI format tool calls
  toolCallId  String?  // For tool response messages
  toolResult  Json?    // Result from tool execution
  
  // Token & Cost Tracking
  tokens      Int?
  cost        Float?
  latency     Int?     // Response latency in ms
  
  // Provider Info
  provider    String?  // Which provider generated this
  model       String?  // Which model generated this
  
  createdAt   DateTime @default(now())
  
  thread      Thread   @relation(fields: [threadId], references: [id], onDelete: Cascade)

  @@index([threadId])
  @@index([role])
  @@index([createdAt])
}

// ============================================================================
// MULTI-AGENT TASK ORCHESTRATION
// ============================================================================

model Task {
  id              String   @id @default(cuid())
  userId          String
  description     String   @db.Text
  strategy        String   // sequential, parallel, hierarchical, consensus
  
  // Configuration
  maxIterations   Int      @default(10)
  timeoutMs       Int      @default(300000) // 5 minutes default
  
  // Status
  status          String   @default("pending") // pending, running, completed, failed
  
  // Results
  output          String?  @db.Text
  error           String?  @db.Text
  
  // Cost Tracking
  totalTokens     Int      @default(0)
  totalCost       Float    @default(0.0)
  executionTimeMs Int?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  completedAt     DateTime?
  
  executions      TaskExecution[]

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

model TaskExecution {
  id          String   @id @default(cuid())
  taskId      String
  agentId     String
  
  // Execution Details
  startTime   DateTime @default(now())
  endTime     DateTime?
  success     Boolean  @default(false)
  
  // Input/Output
  input       String?  @db.Text
  output      String?  @db.Text
  error       String?  @db.Text
  
  // Tool Calls Made
  toolCalls   Json?
  
  // Cost Tracking
  tokens      Int      @default(0)
  cost        Float    @default(0.0)
  
  task        Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  agent       Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)

  @@index([taskId])
  @@index([agentId])
  @@index([startTime])
}

// ============================================================================
// MEMORY & KNOWLEDGE (Optional - Feature Flag for Render)
// ============================================================================

// Uncomment if ENABLE_VECTOR_SEARCH=true in .env
// Requires pgvector extension

// model Memory {
//   id          String   @id @default(cuid())
//   userId      String
//   content     String   @db.Text
//   embedding   Unsupported("vector(1536)")? // pgvector type
//   
//   // Metadata
//   source      String?  // Where this memory came from
//   relevance   Float?   // Relevance score (0-1)
//   
//   createdAt   DateTime @default(now())
//   updatedAt   DateTime @updatedAt
//   
//   @@index([userId])
// }

// ============================================================================
// ANALYTICS & COST TRACKING
// ============================================================================

model UsageLog {
  id          String   @id @default(cuid())
  userId      String
  provider    String
  model       String
  
  // Token Usage
  promptTokens      Int
  completionTokens  Int
  totalTokens       Int
  
  // Cost
  cost        Float
  
  // Context
  endpoint    String?  // agent/chat, agent/task, etc.
  success     Boolean  @default(true)
  
  timestamp   DateTime @default(now())

  @@index([userId])
  @@index([provider])
  @@index([timestamp])
}
